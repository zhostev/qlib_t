## 问题分析

错误信息：`instrument: {'__DEFAULT_FREQ': '/home/idea/.qlib/qlib_data/cn_data'} does not contain data for day`

### 根本原因
1. 在 `file_storage.py` 中，`support_freq` 属性返回的是 `Freq` 对象列表
2. 而 `self.freq` 是字符串类型（如 'day'）
3. 当检查 `self.freq in self.support_freq` 时，字符串和 `Freq` 对象永远不会相等
4. 另外，当 `calendars` 目录不存在或没有 `.txt` 文件时，`freq_l` 会是空的，导致没有支持的频率

### 修复方案

1. **修复比较逻辑**：在 `uri` 属性中，将 `self.freq` 转换为 `Freq` 对象后再进行比较
2. **确保 support_freq 返回正确的频率列表**：当 `calendars` 目录不存在时，提供默认的支持频率

### 具体修改

**文件**：`/home/idea/code/qlib_t/qlib/data/storage/file_storage.py`

**修改点1**：在 `uri` 属性中，将 `self.freq` 转换为 `Freq` 对象
```python
@property
def uri(self) -> Path:
    if Freq(self.freq) not in self.support_freq:
        raise ValueError(f"{self.storage_name}: {self.provider_uri} does not contain data for {self.freq}")
    return self.dpm.get_data_uri(self.freq).joinpath(f"{self.storage_name}s", self.file_name)
```

**修改点2**：在 `support_freq` 属性中，当 `calendars` 目录不存在时，添加默认支持的频率
```python
@property
def support_freq(self) -> List[str]:
    _v = "_support_freq"
    if hasattr(self, _v):
        return getattr(self, _v)
    if len(self.provider_uri) == 1 and C.DEFAULT_FREQ in self.provider_uri:
        calendar_dir = self.dpm.get_data_uri(C.DEFAULT_FREQ).joinpath("calendars")
        if calendar_dir.exists():
            freq_l = filter(
                lambda _freq: not _freq.endswith("_future"),
                map(lambda x: x.stem, calendar_dir.glob("*.txt")),
            )
        else:
            # 添加默认支持的频率
            freq_l = ["day"]
    else:
        freq_l = self.provider_uri.keys()
    freq_l = [Freq(freq) for freq in freq_l]
    setattr(self, _v, freq_l)
    return freq_l
```

### 预期效果

1. 当 `provider_uri` 包含 `__DEFAULT_FREQ` 时，即使 `calendars` 目录不存在，也会默认支持 'day' 频率
2. 比较 `self.freq` 和 `support_freq` 时，会将字符串转换为 `Freq` 对象，确保正确比较
3. 实验能够正常运行，不再抛出 "does not contain data for day" 错误