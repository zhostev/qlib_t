# QLib前后端解耦方案(MySQL版)

## 问题分析
当前QLib框架中，Web服务和模型训练任务在同一服务器上运行，当模型训练时会占用大量资源，导致Web页面无法打开。需要将Web服务和任务训练进行解耦，确保Web服务的稳定性。

## 架构设计

### 1. 整体架构
- **Web服务**：部署在阿里云服务器(116.62.59.244)，负责接收请求、管理任务状态和返回结果
- **任务队列**：使用MySQL数据库实现，存储训练任务
- **训练节点**：部署在本地服务器(144.0.23.148)，专门用于执行模型训练任务
- **数据库**：共享MySQL数据库，用于存储任务状态、实验结果等信息

### 2. 核心组件

#### 2.1 Web服务端
- 保留现有的FastAPI应用，负责处理HTTP请求
- 实现任务队列管理模块，将训练任务插入到MySQL任务表
- 提供API接口，用于查询任务状态和结果

#### 2.2 任务队列
- 使用MySQL的任务表实现任务队列
- 任务表字段包括：ID、实验ID、任务类型、参数配置、状态、优先级、创建时间、更新时间等
- 支持任务优先级和重试机制

#### 2.3 训练节点
- 部署任务执行器，定期从MySQL任务表中获取待执行任务
- 执行模型训练任务，不影响Web服务性能
- 训练完成后，将结果保存到数据库
- 定期更新任务状态到数据库

### 3. 工作流程

1. 用户通过Web界面提交训练任务
2. Web服务将任务信息插入到MySQL任务表，状态为"pending"
3. 本地训练节点定期查询MySQL任务表，获取状态为"pending"的任务
4. 训练节点获取任务后，更新任务状态为"running"
5. 训练节点执行模型训练，定期更新任务进度
6. 训练完成后，将结果保存到数据库，更新任务状态为"completed"
7. 用户通过Web界面查询任务状态和结果

## 实现步骤

### 1. 数据库设计
- 创建任务队列表，用于存储待执行的任务
- 设计表结构，包括任务ID、实验ID、任务类型、参数配置、状态、优先级、创建时间、更新时间等字段
- 确保任务表支持高效查询和更新

### 2. Web服务端修改
- 修改任务提交逻辑，将任务插入到MySQL任务表
- 保留任务状态查询和结果返回功能
- 实现任务管理API，支持任务的创建、查询、取消等操作

### 3. 训练节点实现
- 创建独立的任务执行器应用
- 实现MySQL任务表监听功能，定期查询待执行任务
- 实现任务执行逻辑，调用现有的训练函数
- 实现任务状态更新功能，定期将任务状态保存到数据库

### 4. 配置和部署
- 配置数据库连接信息，确保两台服务器可以访问同一数据库
- 部署Web服务到阿里云服务器
- 部署训练节点到本地服务器

## 预期效果

- Web服务和模型训练完全解耦，互不影响
- Web页面加载速度不受训练任务影响
- 可以灵活扩展训练节点数量
- 支持任务优先级和重试机制
- 提高系统的可靠性和稳定性

## 技术选型

- **消息中间件**：MySQL数据库
- **Web框架**：FastAPI
- **数据库**：MySQL

## 风险评估

- **数据库性能**：需要优化任务表的查询和更新操作，避免数据库成为瓶颈
- **训练节点故障**：需要实现任务超时机制，确保任务可以被其他节点重新执行
- **并发冲突**：需要使用事务和锁机制，避免多个训练节点同时执行同一个任务

## 后续优化

- 支持分布式训练节点
- 实现任务监控和告警功能
- 支持动态调整训练资源
- 实现训练结果缓存机制

## 与Redis方案对比

| 特性 | MySQL方案 | Redis方案 |
|------|-----------|-----------|
| 性能 | 中等 | 高 |
| 复杂度 | 低（利用现有数据库） | 高（需要额外部署Redis） |
| 可靠性 | 高（支持事务和持久化） | 中（需要配置持久化） |
| 功能 | 支持复杂查询，事务 | 支持发布/订阅，优先级队列 |
| 成本 | 低（无需额外服务） | 高（需要额外服务器资源） |

## 结论

使用MySQL代替Redis作为消息中间件是可行的，特别是在现有系统已经使用MySQL的情况下，可以减少系统复杂度和部署成本。虽然性能不如Redis，但对于模型训练任务来说，性能要求不是特别高，MySQL完全可以满足需求。